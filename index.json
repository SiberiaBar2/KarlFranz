[{"content":"11111111\n","permalink":"http://siberiabear.top/karlfranz/tech/test/","summary":"11111111","title":"Test"},{"content":"随笔 在没有权限时点击保存当前区块的参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // React.FC  const loginViewRef: MutableRefObject\u0026lt;any\u0026gt; = useRef(null); const saveLabelRef = useRef\u0026lt;string\u0026gt;(\u0026#39;\u0026#39;); // event function // 如果label（点击了）存在 ，就把它保存下来 // 再次调用时，没有点击之前的区块，就用上一次的 ... if (label) { saveLabelRef.current = label; } let checkKey = label || saveLabelRef.current; ...   json转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  export const CustomJSON = { parse: str =\u0026gt; { let obj; try { obj = JSON.parse(str || \u0026#39;{}\u0026#39;); } catch (e) { message.error(\u0026#39;JSON.parse Error:\u0026#39;, e); } return obj || {}; }, stringify: obj =\u0026gt; { let str; try { str = JSON.stringify(obj || {}); } catch (e) { message.error(\u0026#39;JSON.stringify error:\u0026#39;, e); } return str || \u0026#39;{}\u0026#39;; } };   批量读取、清空本地存储 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  // 批量存储暂时没有，直接写更方便！  const localArr = [\u0026#39;taskStatus\u0026#39;, \u0026#39;taskTodo\u0026#39;, \u0026#39;taskType\u0026#39;]; const resultArr = {} as any; localArr.forEach(item =\u0026gt; { resultArr[item] = CustomJSON.parse(localStorage.getItem(item)); }); const {taskStatus, taskTodo, taskType} = resultArr; // demo  const LOCAL_KEY = [\u0026#39;ROSE\u0026#39;, \u0026#39;LUCY\u0026#39;, \u0026#39;ALICE\u0026#39;]; const obj = {}; LOCAL_KEY.forEach(item =\u0026gt; { obj[item] = item + \u0026#39;I LOVE YOU\u0026#39;; }) const {ROSE, LUCY, ALICE} = obj; // 批量清空  export const updateTaskData = (key: string, info: any) =\u0026gt; { localStorage.setItem(key, CustomJSON.stringify(info)); }; export const lOCAL_KEY = ((key: string) =\u0026gt; { return [{ key: \u0026#39;taskStatus\u0026#39;, // text是刷新后需要同步到页面的文字，key是操作的某一个操作状态  value: {text: \u0026#39;\u0026#39;, key: \u0026#39;\u0026#39;} }, { key: \u0026#39;taskTodo\u0026#39;, value: {text: \u0026#39;\u0026#39;, key: {operation: \u0026#39;\u0026#39;}} }, { key: \u0026#39;taskType\u0026#39;, value: {text: key} // tab切换时，需要更新本地存储的key  }]; }); lOCAL_KEY(key).forEach(item =\u0026gt; { actions.updateTaskData(item.key, item.value); }); // 补充 const filterStatus = (text: string, key: string) =\u0026gt; { setDefaultStatus(text); setStatusKeywords(key); getSyncStatus(); actions.updateTaskData(\u0026#39;taskStatus\u0026#39;, {text, key}); }; const filterTodo = (text : string, key: TodoKeywords\u0026lt;string\u0026gt;) =\u0026gt; { setDefaultOpera(text); setTodoKeywords(key); getSyncTodo(); actions.updateTaskData(\u0026#39;taskTodo\u0026#39;, {text, key}); };   自定义hook ，马上获取刚刚set的值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  /** * * useSyncCallback * */ import {useState, useEffect, useCallback} from \u0026#39;react\u0026#39;; const useSyncCallback = \u0026lt;T\u0026gt;(callback: (value?: T) =\u0026gt; void, value?: T) =\u0026gt; { const [proxyState, setProxyState] = useState({current: false}); const Func = useCallback(() =\u0026gt; { setProxyState({current: true}); }, []); useEffect(() =\u0026gt; { if (proxyState.current === true) { setProxyState({current: false}); } }, [proxyState]); useEffect(() =\u0026gt; { proxyState.current \u0026amp;\u0026amp; callback(value); }); return Func; }; export default useSyncCallback; // 使用  const [statusKeywords, setStatusKeywords] = useState\u0026lt;string\u0026gt;(ALL_TRANSLATE); const filterStatus = (text: string, key: string) =\u0026gt; { setDefaultStatus(text); setStatusKeywords(key); // 刚刚set完，还是在上一次的渲染函数中，拿不到最新改变后的值，不信可以log  getSyncStatus(); // 调用同步函数，获取改变后最新的值，只在这个函数中可以获得最新的值  actions.updateTaskData(\u0026#39;taskStatus\u0026#39;, {text, key}); }; const getSyncStatus = useSyncCallback\u0026lt;string\u0026gt;(() =\u0026gt; { const data = commonSortParam(justOrback); const requestParams : RequestType = { params: data, type: chooseIndex, todoWords: todoKeywords, status: statusKeywords // ***在这个函数中的todoKeywords是改变后最新的！！  }; getTaskData(requestParams); });   Object.create 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  随风 18:19:17 object.create *****这是 ES6 正式推荐的设置原型对象的方法。***** Object.setPrototypeOf(对象，要添加给前面对象的原型对象) 返回参数为对象本身 获取对象c上的原型对象的全部属性，不含自身属性。 Object.getPrototypeOf(c) 给对象的原型添加属性，不使用构造函数和类的方式。 获取对象的自身属性，不包含原型对象的属性。 Object.getOwnPropertyDescriptors(c) // (包括可枚举和不可枚举的)  var c2 = Object.create(Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c)); 注意： Object.assign() 方法不能正确拷贝 get ，set 属性 var c = new ColoredTriangle(); Object.defineProperty(c,\u0026#39;colorGet\u0026#39;, { enumerable: true, // 设为可枚举，不然 Object.assign 方法会过滤该属性  get(){ return \u0026#34;Could it return \u0026#34; + this.color } }); // 将这里改为assign 会发现 colorGet 前面没有get  var c3 = Object.create(Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c)); 如果是要拷贝原型上的属性，就需要 Object.assign , Object.create, Object.getPrototypeOf 方法结合使用 如果是拷贝get /set 属性，就需要 结合 Ojbect.getOwnPropertyDescriptors 方法 链接：https://www.jianshu.com/p/28d85bebe599    ","permalink":"http://siberiabear.top/karlfranz/tech/%E9%9A%8F%E7%AC%94/","summary":"随笔 在没有权限时点击保存当前区块的参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // React.FC const loginViewRef: MutableRefObject\u0026lt;any\u0026gt; = useRef(null); const saveLabelRef = useRef\u0026lt;string\u0026gt;(\u0026#39;\u0026#39;); // event function // 如果label（点击了）存在 ，就把它保","title":"随笔"},{"content":"React面试题 什么是 jsx 1 2 3 4 5 6 7 8 9  jsx ( javascript xml ) , 是javascript 语法的扩展， jsx\t是React.createElement 的语法糖。 jsx优点： 体现了React申明式的优点，   什么是 React 副作用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  就是除了状态相关的逻辑，比如网络请求，监听事件，查找 dom。 在react中，有些副作用需要清除，有些副作用无需清除。 比如手动变更dom, 记录日志这些都无需清除。 而订阅外部数据源、添加定时器等容易造成内存泄露，就很有必要清除。 例如： 组件已经卸载了，但定时器还没有关闭，那么就会报错！！ // 在组件卸载时，取消订阅外部数据源  // axios 官方支持的 中断请求方法 useEffect(() =\u0026gt; { const source = axios.CancelToken.source(); const fetchData = async () =\u0026gt; { try { const response = await Axios.get(\u0026#34;/companies\u0026#34;, { cancelToken: source.token }); // ...  } catch (error) { if (Axios.isCancel(error)) { //cancelled  } else { throw error; } } }; fetchData() return () =\u0026gt; { source.cancel(); }; }, [companies]); 参看资料： https://www.jianshu.com/p/e1ff909aca88 // 简书  https://www.jianshu.com/p/fdab5a6fa1aa    纯函数 1 2 3 4 5 6 7 8 9 10 11 12 13  概念： 1. 一个函数，它的计算不依赖外部的变量，它就是纯函数。 2. 一个函数在执行过程中发生了外部可变的变化，就不是纯函数，反之则是。 一般来讲就是发生了和运算返回值无关的事，就不是纯函数例如： 修改外部作用域 / 全局变量; 修改传入的参数，发送请求、console.log 、操作dom都属于副作用。   useEffect 和useLayoutEffect 的区别 1 2 3 4 5 6 7 8  useLayoutEffect:是在所有DOM变更之后浏览器渲染之前调用，既同步调用 useEffect:是在组件渲染到屏幕之后执行，既异步调用 useLayoutEffect 相比 useEffect，通过同步执行状态更新可解决一些特性场景下的页面闪烁问题。 useEffect 可以满足百分之99的场景，而且 useLayoutEffect 会阻塞渲染，请谨慎使用   什么是useRef 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  返回的 ref 对象在组件的整个生命周期内保持不变 当更新 current 值时并不会 re-render ，这是与 useState 不同的地方 采用useRef,作为组件实例的变量，保证获取到的数据肯定是最新的。 三、useRef与createRef的区别 在一个组件的正常的生命周期中可以大致分为3个阶段： 从创建组件到挂载到DOM阶段。初始化props以及state, 根据state与props来构建DOM 组件依赖的props以及state状态发生变更，触发更新 销毁阶段 第一个阶段，useRef与createRef没有差别 第二个阶段，createRef每次都会返回个新的引用; 而useRef不会随着组件的更新而重新创建 第三个阶段，两者都会销毁 // 总结 useRef可以用来定义变量，这些变量更改之后不会引起页面重新渲染。 useRef也可以用来区分初始渲染还是更新(通过current有没值，具体见示例库里的didOrUpdate.tsx) 在DOM节点上定义ref属性，通过.current就可以获取到该DOM元素 通过forwardRef就可以给函数子组件传入ref属性。 使用useImperativeHandle用于定义暴露给父组件的ref方法   useEffect使用异步函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  useEffect 不能直接使用async await 语法糖. /* 错误用法 ，effect不支持直接 async await*/ useEffect(async ()=\u0026gt;{ /* 请求数据 */ const res = await getData() },[]); useEffect 的回调参数返回的是一个清除副作用的 clean-up 函数。 因此无法返回 Promise，更无法使用 async/await // 那么如何让useEffect 支持 async await ?  1. useEffect(() =\u0026gt; { (async function getDatas() { await getData(); })(); }, []); return \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;; }; 2. useEffect(() =\u0026gt; { const getDatas = async () =\u0026gt; { const data = await getData(); setData(data); }; getDatas(); }, []);   自定义hook \u0026amp; 高阶组件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  自定义hook ： 将一些常用的，跨越多个组件的hook逻辑代码抽离出去就是一个自定义hook。 自定义 hook 内部仍使用hook, 因此其内部同样也要遵循hook规则。 每个组件间的 state 是完全独立的。 Hook 是一种复用 状态逻辑 的方式，它不复用 state 本身。 事实上 Hook 的每次调用 都有一个完全独立的state —— 因此你可以在单个组件中多次调用同一个自定义 Hook。 // ??? 为什么是独立的state  规则： 1. 函数名以use开头 2. 其他组件调用自定义hook, 也应该放到最顶层。 // 自定义 hook vs 高阶组件  高阶组件同样可以封装重复的逻辑代码，达到代码复用，减少冗余代码的作用。 但是： 1. 高阶组件 没有 自定义hook来的优雅， 2. 高阶组件也会导致组件嵌套层次过深。   ","permalink":"http://siberiabear.top/karlfranz/tech/react%E9%9D%A2%E8%AF%95%E9%A2%98/","summary":"React面试题 什么是 jsx 1 2 3 4 5 6 7 8 9 jsx ( javascript xml ) , 是javascript 语法的扩展， jsx 是React.createElement 的语法糖。","title":"React面试题"},{"content":"1  ssss   ","permalink":"http://siberiabear.top/karlfranz/tech/search/","summary":"1  ssss   ","title":"Ser"},{"content":"aaa\n1  生活像一把无情的...   ","permalink":"http://siberiabear.top/karlfranz/life/","summary":"aaa 1 生活像一把无情的...","title":"Life"},{"content":"读书\n","permalink":"http://siberiabear.top/karlfranz/read/","summary":"读书","title":"Read"}]