[{"content":"自定义hook \u0026mdash; 立即获得setState之后的值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  通常我们在一个函数中使用useState的第二个参数，也就是dispatch 更新state， 在这个setState 的下面我们 log 看看的话， 就会发现我们拿不到我们刚刚才 set 的值， 在刚刚set完调用的函数里，也拿不到最新的值。 const numberChange = (val: number) =\u0026gt; { console.log(\u0026#39;pack\u0026#39;, pack) // 拿不到最新的值，是因为函数和log 一样，也是同步执行的。  setNum(val); getSyncPack(val); //1 传参 }; useEffect(() =\u0026gt; { const fn = async () =\u0026gt; { const result = await axios.get(\u0026#39;/../../../list\u0026#39;); // 接口地址  console.warn(\u0026#39;result\u0026#39;, result); const positions = result.data.data[0]; positions \u0026amp;\u0026amp; setPack(positions); numberChange(1); }; fn(); }, []); 这是 react 的规则所决定的，此时尚在前一轮的渲染中。 ----------------------------------------- react 每次渲染都有独立的state和函数， 拿不到最新值，是因为我们在过去的渲染函数中！ 因此也只能获得那一次渲染中的state。   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  /** * @FilePath: hooks/useSyncCallback * @Author: lixiaofei */ // 在组件中调用此函数，可以立即获得刚刚set 完最新的值，同时支持传参的方式。 import {useState, useEffect, useCallback} from \u0026#39;react\u0026#39;; const useSyncCallback = \u0026lt;T\u0026gt;(callback: (value?: T) =\u0026gt; void) =\u0026gt; { const [proxyState, setProxyState] = useState({current: false}); const [paramsters, setParamsters] = useState\u0026lt;T\u0026gt;(); const Func = useCallback((val: T) =\u0026gt; { setParamsters(val); setProxyState({current: true}); }, []); useEffect(() =\u0026gt; { if (proxyState.current === true) { setProxyState({current: false}); } }, [proxyState]); useEffect(() =\u0026gt; { proxyState.current \u0026amp;\u0026amp; callback(paramsters); }); return Func; }; export default useSyncCallback;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 组件中使用 .... ... const [pack, setPack] = useState\u0026lt;any\u0026gt;({}); const getSyncPack = useSyncCallback\u0026lt;number\u0026gt;(val =\u0026gt; { // val 传递的参数  console.warn(\u0026#39;val\u0026#39;, val); // 在这个函数内部可以 log 到最新的值  // 这里是为了实时获得首次 effect 从接口获取的 pack的对象属性  if (val) { const newList: SwitchList[] = []; for (let i = 0; i \u0026lt; val; i++) { newList.push({ label: `位置${i + 1}: `, inpVal: pack[`position${i + 1}`], swiVal: pack[`position${i + 1}Enable`], }); } setList(newList); } }); const numberChange = (val: number) =\u0026gt; { setNum(val); getSyncPack(val); //1 传参 };   ","permalink":"http://siberiabear.top/karlfranz/tech/%E7%AB%8B%E5%8D%B3%E8%8E%B7%E5%8F%96usestate%E6%9B%B4%E6%96%B0%E7%9A%84%E5%80%BC/","summary":"自定义hook \u0026mdash; 立即获得setState之后的值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 通常我们在一个函数","title":"立即获取useState更新的值"},{"content":"react less 全局 / 深度选择器 use 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  /* * 在最近的项目中，是使用 import styles from \u0026#39;./index.less\u0026#39; 这种方式， \u0026amp; * 发现这种方式引入的类名下无法选中 ant 的组件名，比如 .ant -btn。 \u0026amp; * 而直接引入的方式样式又不会生效（import \u0026#39;./index.less\u0026#39;）， \u0026amp; * 问了同事，使用 :global 就可以选中修改这个 ant 组件了。 * */ .switch-list-item { display: flex; align-items: center; margin-bottom: 16px; .switch-label { display: inline-block; width: 128px; margin-right: 25px; text-align: right; } :global .ant-switch-checked { background-color: #3369e9; } :global .ant-switch { width: 44px; } :global .ant-switch-checked .ant-switch-handle { left: calc(54%); } }   1  在编写 less 时， 建议采用如上的方式，空出空格, 更加清晰明了。   other 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /* * 一般我们在react组件中的class类名都是 className=\u0026#39;wrap\u0026#39;， \u0026amp; * 引入了classnames 一般是 className={cn(\u0026#39;wrap\u0026#39;)} 、 \u0026amp; * className={cn(\u0026#39;wrap\u0026#39;, {\u0026#39;chooseIndex\u0026#39;: flag === \u0026#39;1\u0026#39;})}, \u0026amp; * 现在可以用 className={styles.wrap} 、 \u0026amp; * className={styles[\u0026#39;switch-list-item\u0026#39;]} 、 \u0026amp; * const colorName = todo === \u0026#39;可用\u0026#39; ? \u0026#39;blue\u0026#39; : \u0026#39;red\u0026#39;; \u0026amp; * className={styles[colorName]} 这种方式。 \u0026amp; * 跟classnames 相比，同样非常灵活。 */   ","permalink":"http://siberiabear.top/karlfranz/tech/react%E5%85%A8%E5%B1%80%E9%80%89%E6%8B%A9%E5%99%A8/","summary":"react less 全局 / 深度选择器 use 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* * 在最近的项目中，是使用 import styles from \u0026#39;./index.less\u0026#39; 这种方式， \u0026amp;","title":"React全局选择器"},{"content":"React 中引入less 1 2 3 4 5 6 7 8  在 当前最新的 less 、 less-loader 支持下， 可以成功引入less。 当前版本： \u0026#34;less\u0026#34;: \u0026#34;^4.1.2\u0026#34;, \u0026#34;less-loader\u0026#34;: \u0026#34;^10.2.0\u0026#34;   1 2 3 4 5 6 7 8 9  项目根目录执行： Git init git add . git commit -m \u0026#39;\u0026#39; npm run eject // 暴露 config/webpack.config.js   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // webpack.config.js 新增  const lessRegex = /\\.less$/; const lessModuleRegex = /\\.module\\.less$/; // modules/rules/oneOf sassModuleRegex 后面  { test: lessRegex, exclude: lessModuleRegex, use: getStyleLoaders( { importLoaders: 1, sourceMap: isEnvProduction ? shouldUseSourceMap : isEnvDevelopment, modules: { mode: \u0026#39;icss\u0026#39;, }, }, \u0026#39;less-loader\u0026#39; ), sideEffects: true, }, { test: lessModuleRegex, use: getStyleLoaders( { importLoaders: 1, sourceMap: isEnvProduction ? shouldUseSourceMap : isEnvDevelopment, modules: \u0026#39;local\u0026#39;, getLocalIdent: getCSSModuleLocalIdent, }, \u0026#39;less-loader\u0026#39; ), },   1  至于老项目中这样新增为什么会报错？题暂时保留疑问   ","permalink":"http://siberiabear.top/karlfranz/tech/react%E4%B8%AD%E4%BD%BF%E7%94%A8less/","summary":"React 中引入less 1 2 3 4 5 6 7 8 在 当前最新的 less 、 less-loader 支持下， 可以成功引入less。 当前版本： \u0026#34;less\u0026#34;: \u0026#34;^4.1.2\u0026#34;, \u0026#34;less-loader\u0026#34;: \u0026#34;^10.2.0\u0026#34; 1 2 3 4 5 6 7 8 9 项目根目录执行： Git init git add","title":"React中使用less"},{"content":"xss 与 csrf 攻击 xss 概念 1 2 3 4  XSS 全称是 Cross Site Scripting(即跨站脚本)，为了和 CSS 区分，故叫它XSS。XSS 攻击是指浏览器中执行恶意脚 本(无论是跨域还是同域)，从而拿到用户的信息并进行操作。   类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  XSS 攻击的方式一般有三种： 存储型、反射型和文档型。 存储型： 一般是将代码存储到数据库，服务器将这些数据取出返回给客户端， 客户端执行这些恶意代码， 从而达到攻击的效果。 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。 反射型： 指一般恶意脚本作为网络请求的一部分。 如： http://sanyuan.com?q=\u0026lt;script\u0026gt;alert(\u0026#34;你完蛋了\u0026#34;)\u0026lt;/script\u0026gt; 服务器拿到q参数，然后将内容返给浏览器端， 浏览器将这些内容作为html的一部分解析， 发现是一段脚本，直接执行，然后就被攻击了 之所以叫它反射型, 是因为恶意脚本是通过作为网络请求的参数，经过服务器，然后再反射到HTML文档中，执行解析。 和存储型不一样的是，服务器并不会存储这些恶意脚本。   文档型 1 2 3 4  文档型的 XSS 攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的 html 文档！ 这样的劫持方式包括WIFI路由器劫持或者本地恶意软件等。   防范措施 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  我们可以发现，三种XSS攻击都是让恶意脚本在浏览器中执行。 措施： 1.不相信用户的输入 无论是前端还是后端，都对用户输入的内容进行转码和过滤 如: \u0026lt;script\u0026gt;alert(\u0026#39;你完蛋了\u0026#39;)\u0026lt;/script\u0026gt; 转码后变为: \u0026amp;lt;script\u0026amp;gt;alert(\u0026amp;#39;你完蛋了\u0026amp;#39;)\u0026amp;lt;/script\u0026amp;gt; 这样的代码在 html 解析的过程中是无法执行的。 当然也可以利用关键词过滤的方式，将 script 标签给删除。那么现在输入的就没有内容了。 2. 利用 CSP CSP，即浏览器中的内容安全策略，它的核心思想就是服务器决定浏览器加载哪些资源， 具体来说可以完成以下功能: 1）限制其他域下的资源加载。 2）禁止向其它域提交数据。 3）提供上报机制，能帮助我们及时发现 XSS 攻击。 3. 利用 HttpOnly 很多 XSS 攻击脚本都是用来窃取Cookie, 而设置 Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值。 这样也能很好的防范 XSS 攻击。   csrf 攻击 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  CSRF(Cross-site request forgery), 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利 用用户目前的登录状态发起跨站请求。 举个例子, 你在某个论坛点击了黑客精心挑选的小姐姐图片，你点击后，进入了一个新的页面。 那么恭喜你，被攻击了:） 1. 自动发起get请求 加入黑客网站里有这样一段代码： \u0026lt;img src=\u0026#34;https://xxx.com/info?user=hhh\u0026amp;count=100\u0026#34;\u0026gt; 进入页面后自动发送get请求， 这里请求会带上你 xxx.com 的cookie 信息，如果你登陆过的话。 如果服务端没有相应的验证机制，就会认为这是一个正常用户的请求， 因为携带了相应的cookie，就可能进行转账汇款或者其他恶意操作。 2. 黑客可能自己写了一个表单，一个自动提交的表单。 同样会携带用户的cookie ，让服务器认为是一个正常用户的操作，让其他恶意操作成为可能。 3. 诱导点击触发get请求 黑客的网站上可能会放一个诱导链接来让你点击， \u0026lt;a href=\u0026#34;https://xxx/info?user=hhh\u0026amp;count=100\u0026#34; taget=\u0026#34;_blank\u0026#34;\u0026gt;点击进入修仙世界\u0026lt;/a\u0026gt; 点击后发送get请求，接下来和上面 ***自动发 GET 请求*** 同理。   防御措施 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  csrf 攻击中的重要一环就是发送目标站点下的cookie, 然后就是这一份cookie 模拟了用户身份， 因此在cookie上下文章是不二之选！ 1. 利用Cookie的SameSite属性 SameSite可以设置为三个值，Strict、Lax和None。 a. Strict 模式下，浏览器完全禁止第三方请求携带cookie, 比如请求 karlfranz.cn 网站只能在 karlfranz.cn域名请求中携带cookie, 其他网站请求都不能。 b. Lax 模式下相对宽松一点，但只能 在get方法请求表单 或 a 发送get请求下可以 携带cookie, 其他情况均不能。 c. 在none模式下， 也就是默认模式，请求会自动携带cookie 。 2. 验证来源站点 这就需要用到请求头中的两个字段 Origin 和 Referer, 其中Origin 只包含域名信息， 而Referer 包含了具体的url路径。 不过这两者都可以伪造，通过Ajax 的自定义请求就可以伪造，安全性略差。 3. CSRF Token Django 是一门后端框架，在它的表单 （template 中）开发表单时， 经常会附上这一段代码： {% csrf_token %} 这就是 csrf token的典型应用， 它的原理是浏览器向服务器发送请求时，服务器生成一个字符串，将其植入返回的页面中， 然后浏览器发送和请求时，就必须带上这个字符串，来让服务器验证是否合法， 如果不合法，就不予以相应。 这个字符串就是 csrf token , 通常第三方站点无法拿到这个token, 因此发出的请求也就被服务器拒绝。   参考资料 1  https://juejin.cn/post/6844904021308735502?utm_source=gold_browser_extension#heading-64   ","permalink":"http://siberiabear.top/karlfranz/tech/xss%E4%B8%8Ecsrf%E6%94%BB%E5%87%BB/","summary":"xss 与 csrf 攻击 xss 概念 1 2 3 4 XSS 全称是 Cross Site Scripting(即跨站脚本)，为了和 CSS 区分，故叫它XSS。XSS 攻击是指浏览器中执行恶意脚 本(无论是","title":"Xss与csrf攻击"},{"content":"ts-check 概念 1 2 3 4 5 6 7  javascript 是弱类型语言，类型校验在一定程度上能够提高代码的健壮性。 typescript 已经对类型有了良好的支持，但对于一些老项目，如果替换成ts 成本和风险都是巨大的。 ts-check 用于js文件，vscode自动支持，非常适合老项目， 对于提高老项目的健壮性、可维护性有一定作用。   使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  // @ts-check 与其他例如 @type 配合使用  // @ts-check /** * 声明函数参数类型 * @param p0 {string} - TS 风格声明 p0 * @param {string} p1 - p1 是 string 类型参数 * @param {string=} p2 - p2 是可选的 string 类型参数 * @param {string} [p3] - 另外一种可选参数写法 * @param {string} [p4=\u0026#34;test\u0026#34;] - p4 是可选的 string 类型参数（默认值为 \u0026#34;test\u0026#34;） * @return {string} - 函数返回值是 string 类型 */ function fn3(p0, p1, p2, p3, p4){ // TODO  return \u0026#39;2\u0026#39; } fn3(\u0026#39;2\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;bb\u0026#39;, \u0026#39;4\u0026#39;) // 其中 p2、 p3, p4 皆是可选参数的写法，如果有就必须是指定的string类型  // 必须 与 @ts-check配合使用  //=========================================  /** * 可以指定 union 类型，如字符串或者布尔值 * @type {(string | boolean)} */ // 这样写只作用于下面第一个变量 let var3 = 1; // 不能将类型“1”分配给类型“string | boolean”。ts(2322)  let a = 2 /** * 用 “return” 说明函数的返回值类型 * @return {number} */ function fn1() { return \u0026#39;1\u0026#39; // return \u0026#39;1\u0026#39; :不能将类型“string”分配给类型“number”。  } /** * 可以像使用 \u0026#34;@return\u0026#34; 一样使用 \u0026#34;@returns\u0026#34; * @returns {{a: string, b: number}} */ function fn2() { return {a: 1, b :2} // a : 不能将类型“number”分配给类型“string”。 } /** * 用 \u0026#34;@typedef\u0026#34; 自定义复杂类型 * @typedef {Object} SpecialType - 创建一个新的类型 \u0026#39;SpecialType\u0026#39; * @property {string} prop1 - SpecialType 属性 prop1 是 string 类型 * @property {number} prop2 - SpecialType 属性 prop2 是 number 类型 * @property {number=} prop3 - SpecialType 属性 prop3 是可选的 number 类型 * @prop {number} [prop4] - SpecialType 属性 prop4 是可选的 number 类型 * @prop {number} [prop5=42] - SpecialType 属性 prop5 是可选的 number 类型（默认值 42）） */ /** @type {SpecialType} */ let specialTypeObject = { // 必选  prop1: 1, // 不能将类型“number”分配给类型“string”  prop2: true, // 不能将类型“boolean”分配给类型“number”。ts(2322)  // 可选  prop3: 2, prop4: \u0026#39;4\u0026#39;, // 不能将类型“string”分配给类型“number”。ts(2322)  prop5: 43 };   参考资料 1  https://imweb.io/topic/59e34d90b72024f03c7f495e   ","permalink":"http://siberiabear.top/karlfranz/tech/tc-check/","summary":"ts-check 概念 1 2 3 4 5 6 7 javascript 是弱类型语言，类型校验在一定程度上能够提高代码的健壮性。 typescript 已经对类型有了良好的支持，但对于一些老项目，如果替换成ts 成","title":"Tc Check"},{"content":"new 和call new 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  function newFactory (context) { // 在传入为null的情况下 this 指向window  var context = context || window; var obj = {}; // 取出构造函数  Constructor = [].shift.call(arguments); // 将新对象的原型指向构造函数的原型  obj.__proto__ = Constructor.prototype; // 将剩余的参数交给构造函数  // 将构造函数执行，并将函数的指向 ----\u0026gt; 执行新对象，  Constructor.call(obj, ...arguments); return obj; }; function Person (name, age, sex) { console.log(\u0026#39;构造name\u0026#39;, name); // 构造name 小明  this.name = name; this.age = age; this.sex = sex; }; Person.prototype.habit = function () { console.warn(\u0026#39;prototype ----\u0026gt; i am \u0026#39; + this.name); // prototype ----\u0026gt; i am 小明  console.warn(\u0026#39;prototype ----\u0026gt; i am \u0026#39; + this.age + \u0026#39;years old\u0026#39;); // prototype ----\u0026gt; i am 18years old  console.warn(\u0026#39;prototype ----\u0026gt; sex \u0026#39; + this.sex); // prototype ----\u0026gt; sex 男  return \u0026#39;1\u0026#39; } Person.prototype.info = \u0026#39;吃零食\u0026#39;; var person1 = newFactory(Person, \u0026#39;小明\u0026#39;, 18, \u0026#39;男\u0026#39;) console.error(\u0026#39;new 的模拟\u0026#39;, person1); // new 的模拟 Person {name: \u0026#39;小明\u0026#39;, age: 18, sex: \u0026#39;男\u0026#39;}  console.warn(\u0026#39;habit\u0026#39;, person1.habit()); // habit 1  console.warn(\u0026#39;name\u0026#39;, person1.name); // name 小明  console.warn(\u0026#39;info\u0026#39;, person1.info); // info 吃零食   call 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  /** * * 在javascript 中 call 一般用于改变this的指向， \u0026amp; * 但更通俗的来讲，call 的作用是为了使执行的函数能够获得原本它获取不到的变量的访问权限。 * */ /** * 在实现原理上，是对希望被访问到的对象，将当前执行的函数以自身变量的形式赋予它， \u0026amp; * 执行完毕再删除这个函数对应的变量。 */ let obj = { value: 10 } function bar(name, age) { console.log(\u0026#39;name = \u0026#39; + name); // name = 木木  console.log(\u0026#39;age = \u0026#39; + age); // age = 18  console.log(\u0026#39;value = \u0026#39; + this.value); // value = 10 } Function.prototype.xf_call = function(context) { var context = context || window context.fn = this var args = [] for(var i = 1; i \u0026lt; arguments.length; i++) { args.push(\u0026#39;arguments[ \u0026#39; + i + \u0026#39; ]\u0026#39;) } var result = eval(\u0026#39;context.fn(\u0026#39; + args + \u0026#39;)\u0026#39;) delete context.fn return result } bar.xf_call(obj, \u0026#39;木木\u0026#39;, 18) console.log(\u0026#39;对象\u0026#39;, obj) // 对象 { value: 10 }   ","permalink":"http://siberiabear.top/karlfranz/tech/new%E5%92%8Ccall/","summary":"new 和call new 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 function newFactory (context) { // 在传入为null的情况下 this 指向window","title":"New和call"},{"content":"随笔 在没有权限时点击保存当前区块的参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // React.FC  const loginViewRef: MutableRefObject\u0026lt;any\u0026gt; = useRef(null); const saveLabelRef = useRef\u0026lt;string\u0026gt;(\u0026#39;\u0026#39;); // event function // 如果label（点击了）存在 ，就把它保存下来 // 再次调用时，没有点击之前的区块，就用上一次的 ... if (label) { saveLabelRef.current = label; } let checkKey = label || saveLabelRef.current; ...   json转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  export const CustomJSON = { parse: str =\u0026gt; { let obj; try { obj = JSON.parse(str || \u0026#39;{}\u0026#39;); } catch (e) { message.error(\u0026#39;JSON.parse Error:\u0026#39;, e); } return obj || {}; }, stringify: obj =\u0026gt; { let str; try { str = JSON.stringify(obj || {}); } catch (e) { message.error(\u0026#39;JSON.stringify error:\u0026#39;, e); } return str || \u0026#39;{}\u0026#39;; } };   批量读取、清空本地存储 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  // 批量存储暂时没有，直接写更方便！  const localArr = [\u0026#39;taskStatus\u0026#39;, \u0026#39;taskTodo\u0026#39;, \u0026#39;taskType\u0026#39;]; const resultArr = {} as any; localArr.forEach(item =\u0026gt; { resultArr[item] = CustomJSON.parse(localStorage.getItem(item)); }); const {taskStatus, taskTodo, taskType} = resultArr; // demo  const LOCAL_KEY = [\u0026#39;ROSE\u0026#39;, \u0026#39;LUCY\u0026#39;, \u0026#39;ALICE\u0026#39;]; const obj = {}; LOCAL_KEY.forEach(item =\u0026gt; { obj[item] = item + \u0026#39;I LOVE YOU\u0026#39;; }) const {ROSE, LUCY, ALICE} = obj; // 批量清空  export const updateTaskData = (key: string, info: any) =\u0026gt; { localStorage.setItem(key, CustomJSON.stringify(info)); }; export const lOCAL_KEY = ((key: string) =\u0026gt; { return [{ key: \u0026#39;taskStatus\u0026#39;, // text是刷新后需要同步到页面的文字，key是操作的某一个操作状态  value: {text: \u0026#39;\u0026#39;, key: \u0026#39;\u0026#39;} }, { key: \u0026#39;taskTodo\u0026#39;, value: {text: \u0026#39;\u0026#39;, key: {operation: \u0026#39;\u0026#39;}} }, { key: \u0026#39;taskType\u0026#39;, value: {text: key} // tab切换时，需要更新本地存储的key  }]; }); lOCAL_KEY(key).forEach(item =\u0026gt; { actions.updateTaskData(item.key, item.value); }); // 补充 const filterStatus = (text: string, key: string) =\u0026gt; { setDefaultStatus(text); setStatusKeywords(key); getSyncStatus(); actions.updateTaskData(\u0026#39;taskStatus\u0026#39;, {text, key}); }; const filterTodo = (text : string, key: TodoKeywords\u0026lt;string\u0026gt;) =\u0026gt; { setDefaultOpera(text); setTodoKeywords(key); getSyncTodo(); actions.updateTaskData(\u0026#39;taskTodo\u0026#39;, {text, key}); };   自定义hook ，马上获取刚刚set的值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  /** * * useSyncCallback * */ import {useState, useEffect, useCallback} from \u0026#39;react\u0026#39;; const useSyncCallback = \u0026lt;T\u0026gt;(callback: (value?: T) =\u0026gt; void, value?: T) =\u0026gt; { const [proxyState, setProxyState] = useState({current: false}); const Func = useCallback(() =\u0026gt; { setProxyState({current: true}); }, []); useEffect(() =\u0026gt; { if (proxyState.current === true) { setProxyState({current: false}); } }, [proxyState]); useEffect(() =\u0026gt; { proxyState.current \u0026amp;\u0026amp; callback(value); }); return Func; }; export default useSyncCallback; // 使用  const [statusKeywords, setStatusKeywords] = useState\u0026lt;string\u0026gt;(ALL_TRANSLATE); const filterStatus = (text: string, key: string) =\u0026gt; { setDefaultStatus(text); setStatusKeywords(key); // 刚刚set完，还是在上一次的渲染函数中，拿不到最新改变后的值，不信可以log  getSyncStatus(); // 调用同步函数，获取改变后最新的值，只在这个函数中可以获得最新的值  actions.updateTaskData(\u0026#39;taskStatus\u0026#39;, {text, key}); }; const getSyncStatus = useSyncCallback\u0026lt;string\u0026gt;(() =\u0026gt; { const data = commonSortParam(justOrback); const requestParams : RequestType = { params: data, type: chooseIndex, todoWords: todoKeywords, status: statusKeywords // ***在这个函数中的todoKeywords是改变后最新的！！  }; getTaskData(requestParams); });   Object.create 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  随风 18:19:17 object.create *****这是 ES6 正式推荐的设置原型对象的方法。***** Object.setPrototypeOf(对象，要添加给前面对象的原型对象) 返回参数为对象本身 获取对象c上的原型对象的全部属性，不含自身属性。 Object.getPrototypeOf(c) 给对象的原型添加属性，不使用构造函数和类的方式。 获取对象的自身属性，不包含原型对象的属性。 Object.getOwnPropertyDescriptors(c) // (包括可枚举和不可枚举的)  var c2 = Object.create(Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c)); 注意： Object.assign() 方法不能正确拷贝 get ，set 属性 var c = new ColoredTriangle(); Object.defineProperty(c,\u0026#39;colorGet\u0026#39;, { enumerable: true, // 设为可枚举，不然 Object.assign 方法会过滤该属性  get(){ return \u0026#34;Could it return \u0026#34; + this.color } }); // 将这里改为assign 会发现 colorGet 前面没有get  var c3 = Object.create(Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c)); 如果是要拷贝原型上的属性，就需要 Object.assign , Object.create, Object.getPrototypeOf 方法结合使用 如果是拷贝get /set 属性，就需要 结合 Ojbect.getOwnPropertyDescriptors 方法 链接：https://www.jianshu.com/p/28d85bebe599    ","permalink":"http://siberiabear.top/karlfranz/tech/%E9%9A%8F%E7%AC%94/","summary":"随笔 在没有权限时点击保存当前区块的参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // React.FC const loginViewRef: MutableRefObject\u0026lt;any\u0026gt; = useRef(null); const saveLabelRef = useRef\u0026lt;string\u0026gt;(\u0026#39;\u0026#39;); // event function // 如果label（点击了）存在 ，就把它保","title":"随笔"},{"content":"React面试题 什么是 jsx 1 2 3 4 5 6 7 8 9  jsx ( javascript xml ) , 是javascript 语法的扩展， jsx\t是React.createElement 的语法糖。 jsx优点： 体现了React申明式的优点，   什么是 React 副作用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  就是除了状态相关的逻辑，比如网络请求，监听事件，查找 dom。 在react中，有些副作用需要清除，有些副作用无需清除。 比如手动变更dom, 记录日志这些都无需清除。 而订阅外部数据源、添加定时器等容易造成内存泄露，就很有必要清除。 例如： 组件已经卸载了，但定时器还没有关闭，那么就会报错！！ // 在组件卸载时，取消订阅外部数据源  // axios 官方支持的 中断请求方法 useEffect(() =\u0026gt; { const source = axios.CancelToken.source(); const fetchData = async () =\u0026gt; { try { const response = await Axios.get(\u0026#34;/companies\u0026#34;, { cancelToken: source.token }); // ...  } catch (error) { if (Axios.isCancel(error)) { //cancelled  } else { throw error; } } }; fetchData() return () =\u0026gt; { source.cancel(); }; }, [companies]); 参看资料： https://www.jianshu.com/p/e1ff909aca88 // 简书  https://www.jianshu.com/p/fdab5a6fa1aa    纯函数 1 2 3 4 5 6 7 8 9 10 11 12 13  概念： 1. 一个函数，它的计算不依赖外部的变量，它就是纯函数。 2. 一个函数在执行过程中发生了外部可变的变化，就不是纯函数，反之则是。 一般来讲就是发生了和运算返回值无关的事，就不是纯函数例如： 修改外部作用域 / 全局变量; 修改传入的参数，发送请求、console.log 、操作dom都属于副作用。   useEffect 和useLayoutEffect 的区别 1 2 3 4 5 6 7 8  useLayoutEffect:是在所有DOM变更之后浏览器渲染之前调用，既同步调用 useEffect:是在组件渲染到屏幕之后执行，既异步调用 useLayoutEffect 相比 useEffect，通过同步执行状态更新可解决一些特性场景下的页面闪烁问题。 useEffect 可以满足百分之99的场景，而且 useLayoutEffect 会阻塞渲染，请谨慎使用   什么是useRef 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  返回的 ref 对象在组件的整个生命周期内保持不变 当更新 current 值时并不会 re-render ，这是与 useState 不同的地方 采用useRef,作为组件实例的变量，保证获取到的数据肯定是最新的。 三、useRef与createRef的区别 在一个组件的正常的生命周期中可以大致分为3个阶段： 从创建组件到挂载到DOM阶段。初始化props以及state, 根据state与props来构建DOM 组件依赖的props以及state状态发生变更，触发更新 销毁阶段 第一个阶段，useRef与createRef没有差别 第二个阶段，createRef每次都会返回个新的引用; 而useRef不会随着组件的更新而重新创建 第三个阶段，两者都会销毁 // 总结 useRef可以用来定义变量，这些变量更改之后不会引起页面重新渲染。 useRef也可以用来区分初始渲染还是更新(通过current有没值，具体见示例库里的didOrUpdate.tsx) 在DOM节点上定义ref属性，通过.current就可以获取到该DOM元素 通过forwardRef就可以给函数子组件传入ref属性。 使用useImperativeHandle用于定义暴露给父组件的ref方法   useEffect使用异步函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  useEffect 不能直接使用async await 语法糖. /* 错误用法 ，effect不支持直接 async await*/ useEffect(async ()=\u0026gt;{ /* 请求数据 */ const res = await getData() },[]); useEffect 的回调参数返回的是一个清除副作用的 clean-up 函数。 因此无法返回 Promise，更无法使用 async/await // 那么如何让useEffect 支持 async await ?  1. useEffect(() =\u0026gt; { (async function getDatas() { await getData(); })(); }, []); return \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;; }; 2. useEffect(() =\u0026gt; { const getDatas = async () =\u0026gt; { const data = await getData(); setData(data); }; getDatas(); }, []);   自定义hook \u0026amp; 高阶组件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  自定义hook ： 将一些常用的，跨越多个组件的hook逻辑代码抽离出去就是一个自定义hook。 自定义 hook 内部仍使用hook, 因此其内部同样也要遵循hook规则。 每个组件间的 state 是完全独立的。 Hook 是一种复用 状态逻辑 的方式，它不复用 state 本身。 事实上 Hook 的每次调用 都有一个完全独立的state —— 因此你可以在单个组件中多次调用同一个自定义 Hook。 // ??? 为什么是独立的state  规则： 1. 函数名以use开头 2. 其他组件调用自定义hook, 也应该放到最顶层。 // 自定义 hook vs 高阶组件  高阶组件同样可以封装重复的逻辑代码，达到代码复用，减少冗余代码的作用。 但是： 1. 高阶组件 没有 自定义hook来的优雅， 2. 高阶组件也会导致组件嵌套层次过深。   ","permalink":"http://siberiabear.top/karlfranz/tech/react%E9%9D%A2%E8%AF%95%E9%A2%98/","summary":"React面试题 什么是 jsx 1 2 3 4 5 6 7 8 9 jsx ( javascript xml ) , 是javascript 语法的扩展， jsx 是React.createElement 的语法糖。","title":"React面试题"},{"content":"1  ssss   ","permalink":"http://siberiabear.top/karlfranz/tech/search/","summary":"1  ssss   ","title":"Ser"},{"content":"aaa\n1  生活像一把无情的...   ","permalink":"http://siberiabear.top/karlfranz/life/","summary":"aaa 1 生活像一把无情的...","title":"Life"},{"content":"读书\n","permalink":"http://siberiabear.top/karlfranz/read/","summary":"读书","title":"Read"}]